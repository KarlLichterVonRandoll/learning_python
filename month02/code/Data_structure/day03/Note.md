## 树形结构

### 基础概念 

1.定义
* 树（Tree）是n（n≥0）个节点的有限集合T，它满足两个条件：  
  1.有且仅有一个特定的称为根（Root）的节点；  
  2.其余的节点可以分为m（m≥0）个互不相交的有限集合T1、T2、……、Tm，其中每一个集合又是一棵树，并称为其根的子树（Subtree）。

2.基本概念 
 
* 一个节点的子树的个数称为该节点的度数，一棵树的度数是指该树中节点的最大度数。

* 度数为零的节点称为树叶或终端节点，度数不为零的节点称为分支节点，除根节点外的分支节点称为内部节点。

* 一个节点的子树之根节点称为该节点的子节点，该节点称为它们的父节点，同一节点的各个子节点之间称为兄弟节点。一棵树的根节点没有父节点，叶节点没有子节点。

* 一个节点系列k1,k2, ……,ki,ki+1, ……,kj,并满足ki是ki+1的父节点，就称为一条从k1到kj的路径，路径的长度为j-1,即路径中的边数。路径中前面的节点是后面节点的祖先，后面节点是前面节点的子孙。

* 节点的层数等于父节点的层数加一，根节点的层数定义为一。树中节点层数的最大值称为该树的高度或深度。

* m（m≥0）棵互不相交的树的集合称为森林。树去掉根节点就成为森林，森林加上一个新的根节点就成为树。

### 二叉树

#### 定义与特征
1.定义
* 二叉树（Binary Tree）是n（n≥0）个节点的有限集合，它或者是空集（n＝0
），或者是由一个根节点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。二叉树与普通有序树不同，二叉树严格区分左孩子和右孩子，即使只有一个子节点也要区分左右。

2.二叉树的特征
* 二叉树第i（i≥1）层上的节点最多为$2^{i-1}$个。

* 深度为k（k≥1）的二叉树最多有$2^k－1$个节点。

* 在任意一棵二叉树中，树叶的数目比度数为2的节点的数目多一。

* 满二叉树 ：深度为k（k≥1）时有$2^k－1$个节点的二叉树。

* 完全二叉树 ：只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边的若干位置上。

#### 二叉树的遍历

* 遍历 ：沿某条搜索路径周游二叉树，对树中的每一个节点访问一次且仅访问一次。

> 1.先序遍历： 先访问树根，再访问左子树，最后访问右子树；  
> 2.中序遍历： 先访问左子树，再访问树根，最后访问右子树；  
> 3.后序遍历： 先访问左子树，再访问右子树，最后访问树根；  
> 4.层次遍历： 从根节点开始，逐层从左向右进行遍历。

### 递归思想和实践

1.什么是递归？
* 所谓递归函数是指一个函数的函数体中直接调用或间接调用了该函数自身的函数。
  这里的直接调用是指一个函数的函数体中含有调用自身的语句，
  间接调用是指一个函数在函数体里有调用了其它函数，而其它函数又反过来调用了该函数的情况。

2.递归函数调用的执行过程分为两个阶段  
* 递推阶段：从原问题出发，按递归公式递推从未知到已知，最终达到递归终止条件。
* 回归阶段：按递归终止条件求出结果，逆向逐步代入递归公式，回归到原问题求解。

3.优点与缺点 
* 优点：递归可以把问题简单化，让思路更为清晰,代码更简洁
* 缺点：递归因系统环境影响大，当递归深度太大时，可能会得到不可预知的结果


#### 二叉树顺序存储
* 二叉树本身是一种递归结构，可以使用Python list 进行存储。但是如果二叉树的结构比较稀疏的话浪费的空间是比较多的。

* 空结点用None表示

* 非空二叉树用包含三个元素的列表[d,l,r]表示，其中d表示根结点，l，r表示左子树和右子树。
```
['A',['B',None,None
     ],
     ['C',['D',['F',None,None],
               ['G',None,None],
          ],     
          ['E',['H',None,None],
               ['I',None,None],
          ],
     ]
]
```

#### 二叉树链式存储
* 二叉树遍历 btree.py


## 算法基础

### 基础概念特征

1.定义

* 算法（Algorithm）是一个有穷规则（或语句、指令）的有序集合。
  它确定了解决某一问题的一个运算序列。对于问题的初始输入，通过算法有限步的运行，产生一个或多个输出。

> 数据的逻辑结构与存储结构密切相关:

* 算法设计: 取决于选定的逻辑结构
* 算法实现: 依赖于采用的存储结构

2.算法的特性
   
* 有穷性 —— 算法执行的步骤（或规则）是有限的；
* 确定性 —— 每个计算步骤无二义性；
* 可行性 —— 每个计算步骤能够在有限的时间内完成；
* 输入 ，输出 —— 存在数据的输入和出输出

3.评价算法好坏的方法
   
* 正确性：运行正确是一个算法的前提。
* 可读性：容易理解、容易编程和调试、容易维护。
* 健壮性：考虑情况全面，不容以出现运行错误。
* 时间效率高：算法消耗的时间少。
* 储存量低：占用较少的存储空间。

### 时间复杂度计算

* 算法效率——用依据该算法编制的程序在计算机上执行所消耗的时间来度量。“O”表示一个数量级的概念。根据算法中语句执行的最大次数（频度）来 估算一个算法执行时间的数量级。

> 计算方法：
>> 写出程序中所有运算语句执行的次数，进行加和
>> 如果得到的结果是常量则时间复杂度为1
>> 如果得到的结果中存在变量n则取n的最高次幂作为时间复杂度
* 常用时间复杂度所耗费时间从小到大依次为:  
  O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

### 排序和查找

#### 排序

排序(Sort)是将无序的记录序列（或称文件）调整成有序的序列。

常见排序方法：

* 冒泡排序  
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

* 选择排序  
工作原理为，首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。

* 插入排序  
对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

* 快速排序  
步骤:
> 从数列中挑出一个元素，称为 "基准"（pivot），
> 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
> 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

常见排序代码实现 m1905/Data_structure/sort

### 查找

查找(或检索)是在给定信息集上寻找特定信息元素的过程。

##### 二分法查找

当数据量很大适宜采用该方法。采用二分法查找时，数据需是排好序的。