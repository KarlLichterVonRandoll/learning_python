## IO并发

### IO 分类

>IO分类：阻塞IO ，非阻塞IO，IO多路复用，异步IO等


#### 阻塞IO 

1.定义：在执行IO操作时如果执行条件不满足则阻塞。阻塞IO是IO的默认形态。

2.效率：阻塞IO是效率很低的一种IO。但是由于逻辑简单所以是默认IO行为。

3.阻塞情况：
* 因为某种执行条件没有满足造成的函数阻塞
e.g.  accept   input   recv

* 处理IO的时间较长产生的阻塞状态
e.g. 网络传输，大文件读写
			

####　非阻塞IO

1.定义 ：通过修改IO属性行为，使原本阻塞的IO变为非阻塞的状态。

* 设置套接字为非阻塞IO

 >sockfd.setblocking(bool)  
 功能：设置套接字为非阻塞IO  
 参数：默认为True，表示套接字IO阻塞；设置为False则套接字IO变为非阻塞

* 超时检测 ：设置一个最长阻塞时间，超过该时间后则不再阻塞等待。

 >sockfd.settimeout(sec)  
 功能：设置套接字的超时时间  
 参数：设置的时间  
 
### IO多路复用

1.定义

> 同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。  
 以此形成可以同时处理多个IO的行为，避免一个IO阻塞造成其他IO均无法执行，提高了IO执行效率。

2.具体方案

> select方法 ： windows  linux  unix

> poll方法： linux  unix

> epoll方法： linux


#### select 方法

***代码实现: day5/select_server.py***

```
rs, ws, xs=select(rlist, wlist, xlist, [timeout])

功能：监控IO事件，阻塞等待IO发生
参数：rlist  列表  存放关注的等待发生的IO事件, 如接受客户端连接
     wlist  列表  存放关注的要主动处理的IO事件, 如文件读写、发信息
     xlist  列表  存放关注的出现异常要处理的IO
     timeout  超时时间

返回值:rs 列表  rlist中准备就绪的IO
      ws 列表  wlist中准备就绪的IO
      xs 列表  xlist中准备就绪的IO
```

* select 实现tcp服务

[1] 将关注的IO (s:监听套接字, c:每个客户端专属套接字) 放入对应的监控类别列表  
[2] 通过select函数进行监控  
[3] 遍历select返回值列表，确定就绪IO事件  
[4] 处理发生的IO事件

> 注意
>> wlist中如果存在IO事件，则select立即返回给ws
>> 处理IO过程中不要出现死循环占有服务端的情况
>> IO多路复用消耗资源较少，效率较高
>> select 最多监控1024个 IO

###@@扩展: 位运算

定义 ： 将整数转换为二进制，按二进制位进行运算

运算符号： 
>		&  按位与
>		|  按位或
>		^  按位异或
>		<< 左移
>		>> 右移

```
e.g.  14 --> 01110
      19 --> 10011

14 & 19 = 00010 = 2  一0则0
14 | 19 = 11111 = 31 一1则1
14 ^ 19 = 11101 = 29 相同为0不同为1
14 << 2 = 111000 = 56 向左移动低位补0
14 >> 2 = 11 = 3  向右移动去掉低位
```

#### poll方法

***代码实现: day5/poll_server.py***

```
p = select.poll()
功能 ： 创建poll对象
返回值： poll对象
```

```	
p.register(fd,event)   
功能: 注册关注的IO事件
参数：fd  要关注的IO
     event  要关注的IO事件类型
     常用类型：POLLIN  读IO事件（rlist）
             POLLOUT 写IO事件 (wlist)
             POLLERR 异常IO  （xlist）
             POLLHUP 断开连接 
     e.g. p.register(sockfd,POLLIN|POLLERR)

p.unregister(fd)
功能：取消对IO的关注
参数：IO对象或者IO对象的fileno
```

```
events = p.poll()
功能： 阻塞等待监控的IO事件发生
返回值： 返回发生的IO
        events格式  [(fileno,event),()....]
        每个元组为一个就绪IO，元组第一项是该IO的fileno，第二项为该IO就绪的事件类型
```

poll_server 步骤
```   
【1】 创建套接字
【2】 将套接字register
【3】 创建查找字典，并维护
【4】 循环监控IO发生
【5】 处理发生的IO
```

#### epoll方法

***代码实现: day5/epoll_server.py***

1.使用方法 ： 基本与poll相同

* 生成对象改为 epoll()
* 将所有事件类型改为EPOLL类型
	
2.epoll特点

* epoll 效率比select poll要高
* epoll 监控IO数量比select要多
* epoll 的触发方式比poll要多 （EPOLLET边缘触发）
> 水平触发：当有就绪的 IO 时，会一直提醒处理，直到被处理  
  边缘触发：当有就绪的 IO 时，不会一直提醒，直到下次有就绪的 IO 时再提醒
* 对于同一对象，epoll 不允许两次注册(p.register(fd,event))，必须取消后再注册


### 异步 I/O
* 异步IO是非阻塞的,其根本原因也是因为,在内核态向用户态转发结束后,才叫进程来接收,进程不用等待,直接拿到数据.

#### 同步异步区别
* 同步IO是快餐性质餐好了以后你过去取食物,拿食物回到座位,这个过程是耗时的操作.
* 异步IO是大餐性质,我们餐好了以后,大家还在座位上聊天,服务员就会把食物端到桌子上,然后我们吃就可以了,高端服务.

* 我们可以用IO多路复用写一个SocketServer实现单线程下的大并发。但是IO多路复用本质是还是同步IO,
因为数据从内核态到用户态的拷贝需要等待操作系统完成,只有异步 I/O本质是是异步IO,
本质上异步 I/O会当数据从内核态拷贝到用户态这一过程完成之后再去通知程序直接取走,因为I/O操作是系统完成,所以这才是真正意义上的异步IO操作.

### 总结
* select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，
而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。


