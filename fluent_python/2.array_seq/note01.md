## 内置序列类型

* 容器序列:   
> list、tuple 和 collections.deque 这些序列能存放不同类型的数据。

* 扁平序列:   
> str、bytes、bytearray、memoryview 和 array.array,这类序列只能容纳一种类型。

容器序列存放的是它们所包含的任意类型的对象的引用,而扁平序列里存放的是值而不是引用。换句话说,扁平序列其实是一段连续的内存空间。
由此可见扁平序列其实更加紧凑,但是它里面只能存放诸如字符、字节和数值这种基础类型。

* 可变序列:   
> list, bytearray, array.array, collections.deque 和 memoryview。

* 不可变序列:  
> tuple, str 和 bytes。

## 元组

#### 元组不仅仅是不可变的列表

* 元组其实是对数据的记录: 元组中的每个元素都存放了记录中一个字段的数据,外加这个字段的位置。
  正是这个位置信息给数据赋予了意义。

#### 具名元组 collections.nametuple

* collections.nametuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。  
代码实现 namedtuple.py

```
1. 创建具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。
   后者可以是由数个字符串组成的可迭代对象,或者是由空格分隔开的字段名组成的字符串。
   
2. 存放在对应字段里的数据要以一串参数的形式传入到构造函数中
   (注意,元组的构造函数却只接受单一的可迭代对象)。
   
3. 可以通过字段名或者位置来获取一个字段的信息。
```

* 具名元组的一些专有属性  如：_fields 类属性、类方法_make(iterable) 和实例方法 _asdict()。  
代码实现 namedtuple.py
```
1. _fields 属性是一个包含这个类所有字段名称的元组。

2. 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例,
它的作用跟 City(*delhi_data) 是一样的。

3. _asdict() 把具名元组以 collections.OrderedDict 的形式返
回,我们可以利用它来把元组里的信息友好地呈现出来。
```

#### 作为不可变列表的元组

* 除了跟增减元素相关的方法之外,元组支持列表的其他所有方法。
还有一个例外,元组没有__reversed__方法,但是这个方法只是个优化而已,
reversed(my_tuple)这个用法在没有__reversed__ 的情况下也是合法的。

## 切片

> 在 Python 里,像列表(list)、元组(tuple)和字符串(str)这类序列类型都支持切片操作

#### 对对象进行切片

* 我们可以用 s[a : b : c] 的形式对 s 在 a 和 b 之间以 c 为间隔取值，
  c 的值还可以为负,负值意味着反向取值。 
* a:b:c 这种用法只能作为索引或者下标用在 [] 中来返回一个切片对象:  
  slice(a, b, c)。  
  对 seq[start:stop:step] 进行求值的时候,Python 会调用 seq.__getitem__(slice(start, stop, step))。

#### 给切片进行赋值

```
>> l = list(range(10))
>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> l[2:5] = [20, 30]
>> l
[0, 1, 20, 30, 5, 6, 7, 8, 9]

# 如果赋值的对象是一个切片,那么赋值语句的右侧必须是个可迭代对象。
即便只有单独一个值,也要把它转换成可迭代的序列。
>> l[2:5] = 100
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can only assign an iterable

>> l[2:5] = [100]
[0, 1, 100, 6, 7, 8, 9]
```

## 对序列使用 + 和 *

> 通常 + 号两侧的序列由相同类型的数据所构成,在拼接的过程中,两个被操作的序列都不会被
修改, Python会新建一个包含同样类型数据的序列来作为拼接的结果。

> +和 * 都遵循这个规律,不修改原有的操作对象,而是构建一个全新的
序列。

#### 用 * 来初始化一个由列表组成的列表。

* 初始化一个嵌套着几个列表的列表最好的方式是使用列表推导式
```
>>> board = [['_'] * 3 for i in range(3)]
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[1][2] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```

* 另一种方法比较简洁，但实际是错的
```
>>> a = [['_'] * 3] * 3
>>> a
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> a[1][2] = 'X'
>>> a
[['_', '_', 'X'], ['_', '_', 'X'], ['_', '_', 'X']]
```
> 1.外面的列表其实包含 3 个指向同一个列表的引用。当我们不做修改的时候,看起来都还好。  
  
> 2.一旦我们试图标记第 1 行第 2 列的元素,就立马暴露了列表内的 3 个引用指向同一个对象的事实。


* 犯错的本质和以下代码性质相同
```
>>> row = ['_'] * 3
>>> board = []
>>> for i in range(3):
...     board.append(row)  # 三次追加相同的对象 row 到 board
... 
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[1][2] = 'X'
>>> board
[['_', '_', 'X'], ['_', '_', 'X'], ['_', '_', 'X']]
```

* 正确的做法对应以下代码的性质
```
>>> board = []
>>> for i in range(3):
...     row=['_'] * 3  # 这里每次迭代都产生新的对象追加到 board 中
...     board.append(row)
...
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[2][0] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['X', '_', '_']]
```

## 序列的增量赋值 +=  *=
* += 背后的特殊方法是__iadd__ (用于“就地加法”)。但是如果一个类
没有实现这个方法的话,Python 会退一步调用__add__ 。  
```
>> a += b
```
* 对可变序列(例如list, bytearray和array.array)来说,a 会就地改动,就
像调用了 a.extend(b) 一样。但是如果 a 没有实现__iadd__ 的话,a
+= b 这个表达式的效果就变得跟 a = a + b 一样了:首先计算 a + b,得到一个新的对象,然后赋值给 a, 也就是说,在这个表达式中,
变量名会不会被关联到新的对象,完全取决于这个类型有没有实现__iadd__ 这个方法。
对于不可变序列，原本就不支持这个操作

* 而 * =对应特殊方法__imul__, 与+= 不同，* = 支持不可变序列的操作，如元组，但会创建新的元组
```
>>> l = [1, 2, 3]
>>> id(l)
4311953800
>>> l *= 2
>>> l
[1, 2, 3, 1, 2, 3]
>>> id(l)  # 运用增量乘法后,列表的 ID 没变,新元素追加到列表上。
4311953800
>>> t = (1, 2, 3)
>>> id(t)
4312681568
>>> t *= 2
>>> id(t)  # 运用增量乘法后,新的元组被创建。
4301348296
```

#### 一个关于 += 的谜题

```
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> t
(1, 2, [30, 40, 50, 60])
```
以上代码运行会报错，但 t[2] 会被改动，因此需要注意
* 不要把可变对象放在元组里面。
* 增量赋值不是一个原子操作。它虽然抛出了异常,但还是完成了操作。

## 排序：list.sort方法 和 内置函数 sorted
* list.sort 方法会就地排序列表，不会新建一个列表，返回值为 None
* sorted 方法会新建一个列表作为返回值，这个方法接受任何形式的可迭代对象作为参数
* 以上两者都有两个可选参数
```
reverse
如果被设定为 True,被排序的序列里的元素会以降序输出(也就是说把最大值当作最小值来排序)。
这个参数的默认值是 False。

key
一个只有一个参数的函数,这个函数会被用在序列里的每一个元素上,所产生的结果将是排序算法依赖的对比关键字。
比如说,在对一些字符串排序时,可以用 key=str.lower 来实现忽略大小写的排序,或者是用 key=len 进行基于字符串长度的排序。
这个参数的默认值是恒等函数(identity function),也就是默认用元素自己的值来排序。
```


## 用 bisect 来管理已排序的序列
* bisect 模块包含两个主要函数,bisect 和 insort,两个函数都利用二分查找算法来在有序序列中查找或插入元素。

### 使用 bisect 搜索
* 代码实现 bisect01.py
* 代码实现 bisect02.py
```
bisect(haystack, needle) 

在 haystack 里搜索 needle 的位置,该位置满足的条件是,把 needle 插入这个位置之后,haystack 还能保持升序。
也就是在说这个函数返回的位置前面的值,都小于或等于 needle 的值。其中 haystack 必须是一个有序的序列。
你可以先用 bisect(haystack, needle) 查找位置 index,再用 haystack.insert(index, needle) 来插入新值。
但你也可用 insort 来一步到位,并且后者的速度更快一些。
```
* bisect 有两个可选参数 lo 和 hi 来缩小搜寻的范围。
```
lo的默认值是 0,hi 的默认值是序列的长度,即 len() 作用于该序列的
返回值。
其次,bisect 函数其实是 bisect_right 函数的别名,后者还有个姊
妹函数叫 bisect_left。它们的区别在于,bisect_left 返回的插入
位置是原序列中跟被插入元素相等的元素的位置,也就是新元素会被放
置于它相等的元素的前面,而 bisect_right 返回的则是跟它相等的元
素之后的位置。这个细微的差别可能对于整数序列来讲没什么用,但是
对于那些值相等但是形式不同的数据类型来讲,结果就不一样了。
```

### 用bisect.insort插入新元素
* bisect.insort(seq, item) 把变量 item 插入到序列 seq 中,并能保持 seq 的升序顺序。
* 代码实现 bisect_insort.py
* insort 跟 bisect 一样,有 lo 和 hi 两个可选参数用来控制查找的范围。
它也有个变体叫 insort_left,这个变体在背后用的是 bisect_left。


## 当列表不是首选的时候

* 虽然列表既灵活又简单,但面对各类需求时,我们可能会有更好的选择。  
> 比如,要存放 1000 万个浮点数的话,数组(array)的效率要高
得多,因为数组在背后存的并不是 float 对象,而是数字的机器翻译,也就是字节表述。这一点就跟 C 语言中的数组一样。

> 再比如说,如果需要频繁对序列做先进先出的操作,deque(双端队列)的速度应该会更快。

> 如果在你的代码里,包含操作(比如检查一个元素是否出现在一个集合中)的频率很高,用 set(集合)会更合适。
set 专为检查元素是否存在做过优化。但是它并不是序列,因为 set 是无序的。


### 数组 array.array
* 对于一个只包含数字的列表，使用数组更高效。

> python 创建数组需要一个类型码，这个类型码用来表示在底层的 C 语言应该存放怎样的数据类型。
比如 b 类型码代表的是有符号的字符(signed char),因此 array('b') 创建出的数组就只能存放一个字节大小的整数,范围从 -128 到 127,这样在序列
很大的时候,我们能节省很多空间。 

* 代码实现 array01.py

> 用 array.fromfile 从一个二进制文件里读出 1000 万个双精度浮点数只需要 0.1 秒,
这比从文本文件里读取的速度要快 60 倍,因为后者会使用内置的 float 方法把每一行文字转换成浮点数。

> 使用 array.tofile 写入到二进制文件,比以每行一个浮点数的方式把所有数字写入到文本文件要快 7 倍。
另外,1000 万个这样的数在二进制文件里只占用 80 000 000 个字节(每个浮点数占用 8 个字节,不需要任何额外空间),
如果是文本文件的话,我们需要 181 515 739 个字节。

* 数组不支持如 list.sort() 的原地排序，但可以使用 sorted 函数新建一个排序后的数组  
  想要在不打乱次序的情况下为数组添加新的元素,bisect.insort 还是能派上用场
```
a = array.array(a.typecode, sorted(a))

bisect.insort(a, item)
```


### 内存视图 memoryview
* memoryview 是一个内置类,它能让用户在不复制内容的情况下操作同一个数组的不同切片。

haha




