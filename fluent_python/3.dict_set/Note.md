## 第 3 章： 字典和集合

### 具体内容
* 常见的字典操作
* 如何处理查找不到的键
* 标准库中 dict 中的变种
* set 和 frozenset 类型
* 散列表的工作原理
* 散列表带来的潜在影响(什么样的数据类型可作为键、不可预知的顺序,等等)

### 3.1 泛映射类型
* 标准库中所有的映射类型都是利用 dict 实现的，他们都有一个共同的限制：
> 即只有可散列的数据类型才能用作这些映射里的键(只有键有这个要求,值并不需要是可散列的数据类型)。

* 什么是可散列的数据类型 ?
> 如果一个对象是可散列的，那么在这个对象的生命周期中， 他的散列值是不变的，而且这个对象需要实现__hash__方法。
> 另外还需要__eq__方法，这样才能和其他键作比较。如果两个可散列对象是相等的，那么他们的散列值一定是一样的。

> 原子不可变数据库类型 (str,bytes,数值类型) 都是可散列类型。  
> frozenset 也是可散列的。因为 frozenset 中只能容纳可散列类型。
> 对于元组，只有当一个元组中所有元素都是可散列类型的情况下，它才是可散列的。
```
>>> tt = (1, 2, (30, 40))
>>> hash(tt)
8027212646858338501
>>> tl = (1, 2, [30, 40])
>>> hash(tl)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> tf = (1, 2, frozenset([30, 40]))
>>> hash(tf)
-4118419923444501110
```

> 一般来讲用户自定义的类型的对象都是可散列的,散列值就是它们
的 id() 函数的返回值,所以所有这些对象在比较的时候都是不相
等的。如果一个对象实现了__eq__方法,并且在方法中用到了这
个对象的内部状态的话,那么只有当所有这些内部状态都是不可变
的情况下,这个对象才是可散列的。


### 3.2 字典推导式
* 字典推导(dictcomp)可以从任何以键值对作为元素的可迭代对象中构建出字典。
```
>>> s = [(1,'a'), (2,'b'), (3,'c')]
>>> dict01 = {k:v for k, v in s}
>>> dict01
{1: 'a', 2: 'b', 3: 'c'}
>>> dict02 = {k:v.upper() for k,v in dict01.items() if k > 1}
{2: 'B', 3: 'C'}
```


### 3.3 常见的映射方法
* dict、 collections.defaultdict 和 collections.OrderedDict。

#### 使用 setdefault 处理找不到的键
* dict.get 并不是处理找不到的键的最好方法。




